#include <cmath>
#include "dog_math.h"
#include "DogArrays.h"
#include "assert.h"
#include "constants.h"

//////////////////////////////////////////////////////////////////////////////
//  The purpose of this module is to describe common math functions
//  what we'd like to be able to perform in DogPack.
//
// See also:
//
//   $DOGPACK/constants.h  for a list of commonly used constants such as pi.
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// sgnum function.  undefined behavior for x near zero
//////////////////////////////////////////////////////////////////////////////
double dog_math::sgn(double x)
{ return x < 0 ? -1. : 1.; }
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// max of two doubles
//////////////////////////////////////////////////////////////////////////////
double dog_math::Max(double a, double b)
{ return a > b ? a : b; }
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// min of two doubles
//////////////////////////////////////////////////////////////////////////////
double dog_math::Min(double a, double b)
{ return a < b ? a : b; }
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// max of two ints
//////////////////////////////////////////////////////////////////////////////
int dog_math::iMax(int a, int b)
{ return a > b ? a : b; }
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// min of two ints
//////////////////////////////////////////////////////////////////////////////
int dog_math::iMin(int a, int b)
{ return a < b ? a : b; }
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// n choose k
//////////////////////////////////////////////////////////////////////////////
int dog_math::choose(int n, int k)
{
  if (k == 0)
    { return 1; }
  else
    { return (n * choose(n - 1, k - 1)) / k; }
}
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// mod function: eturns n % m, where the result is between 0 and m-1.
//////////////////////////////////////////////////////////////////////////////
int dog_math::iMod(int n, int m)
{
  int modval = n % m;
  return n % m < 0 ? (modval) + m : modval;
}
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// minimum modulus of two double a and b
// returns 0 if a*b<0.
//////////////////////////////////////////////////////////////////////////////
double dog_math::minmod(double a, double b)
{
  if (std::signbit(a))
    {
      if (std::signbit(b))
        { return Max(a, b); }
      return 0.0;
    }

  if (std::signbit(b))
    { return 0.0; }

  return Min(a, b);
}
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// minimum modulus of three doubles
// returns 0 if a, b, and c do not all have same sign
//////////////////////////////////////////////////////////////////////////////
double dog_math::minmod(double a, double b, double c)
{
  if (std::signbit(a))
    {
      if (std::signbit(b) && std::signbit(c))
        { return Max(Max(a, b), c); }
      return 0;
    }
  if (std::signbit(b) || std::signbit(c))
    { return 0; }
  return Min(Min(a, b), c);
}
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// maximum modulus of two double a and b
// returns 0 if a*b<0.
//////////////////////////////////////////////////////////////////////////////
double dog_math::maxmod(double a, double b)
{
  if (std::signbit(a))
    {
      if (std::signbit(b))
        { return Min(a, b); }
      return 0.0;
    }

  if (std::signbit(b))
    { return 0.0; }

  return Max(a, b);
}
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// minmod with total variation bounded adjustment (2 numbers)
//////////////////////////////////////////////////////////////////////////////
double dog_math::minmodTVB(double a, double b, double M, double h)
{
  if (fabs(a) > M * h * h)
    { return minmod(a, b); }
  return a;
}
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// minmod with total variation bounded adjustment (3 numbers)
//////////////////////////////////////////////////////////////////////////////
double dog_math::minmodTVB(double a, double b, double c, double M, double h)
{
  if (fabs(a) > M * h * h)
    { return minmod(a, b, c); }
  return a;
}
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// poor man's Factorial function
// Note: if n < 0, this function returns 1.
//
// See: constants.h: factorial for a single access array of factorials
// 0! through 10!
//////////////////////////////////////////////////////////////////////////////
int dog_math::Factorial(int n)
{
  int result = 1;
  while (n > 1)
    { result *= n--; }
  return result;
}
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// returns true if |a-b|<epsilon
//////////////////////////////////////////////////////////////////////////////
bool dog_math::almost_eq(double a, double b)
{ return fabs(a - b) < constants::EPSILON ? true : false; }
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// round double to nearest integer
//////////////////////////////////////////////////////////////////////////////
int dog_math::round(double a)
{ return (int)floor(a + 0.5); }
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Returns the maximum value of a single vector
//////////////////////////////////////////////////////////////////////////////
double dog_math::MaxVector(const DblArray& vec)
{
#ifdef CHECK_BOUNDS
  assert_eq(vec.get_num_ind(),1);
#endif

  double max = vec.get(1);
  for( int i=2; i<=vec.get_ind_length(1); i++)
    { max = Max(max, vec.get(i)); }
  return max;
}
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Returns the maximum absolute value of a single vector
//////////////////////////////////////////////////////////////////////////////
double dog_math::MaxAbsVector(const DblArray& vec)
{
#ifdef CHECK_BOUNDS
  assert_eq(vec.get_num_ind(),1);
#endif

  double max = fabs(vec.get(1));
  for( int i=2; i<=vec.get_ind_length(1); i++)
    { max = Max(max, fabs(vec.get(i)) ); }
  return max;
}
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Returns a vector containing the maximum value of each component
// in vec1 and vec2
//////////////////////////////////////////////////////////////////////////////
void dog_math::MaxVector(const DblArray& vec1,
                         const DblArray& vec2,
                         DblArray& max)
{
#ifdef CHECK_BOUNDS
  assert_eq(vec1.get_num_ind(),1);
  assert_eq(vec2.get_num_ind(),1);
  assert_eq(max.get_num_ind(),1);

  assert_eq(vec1.get_ind_length(1),vec2.get_ind_length(1));
  assert_eq(max.get_ind_length(1),vec1.get_ind_length(1));
#endif

  for( int i=1; i<=vec1.get_ind_length(1); i++)
    { max.set(i,  Max(vec1.get(i), vec2.get(i)) ); }
}
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Returns a vector containing the maximum absolute value of each component
// in vec1 and vec2
//////////////////////////////////////////////////////////////////////////////
void dog_math::MaxAbsVector(const DblArray& vec1,
                            const DblArray& vec2,
                            DblArray& max)
{
#ifdef CHECK_BOUNDS
  assert_eq(vec1.get_num_ind(),1);
  assert_eq(vec2.get_num_ind(),1);
  assert_eq(max.get_num_ind(),1);

  assert_eq(vec1.get_ind_length(1),vec2.get_ind_length(1));
  assert_eq(max.get_ind_length(1),vec1.get_ind_length(1));
#endif

  for( int i=1; i<=vec1.get_ind_length(1); i++)
    { max.set(i,  Max(fabs(vec1.get(i)), fabs(vec2.get(i))) ); }
}
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Returns the maximum value found in Matrix A
//////////////////////////////////////////////////////////////////////////////
double dog_math::MaxMatrix(const DblArray& A)
{
#ifdef CHECK_BOUNDS
  assert_eq(A.get_num_ind(),2);
#endif

  const int m1 = A.get_ind_length(1);
  const int m2 = A.get_ind_length(2);

  double tmp = A.get(1,1);
  for( int i=1; i<=m1; i++)
    for( int j=1; j<=m2; j++)
      { tmp = Max(tmp, A.get(i,j) ); }

  return tmp;
}
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Returns the maximum absolute value found in Matrix A
//////////////////////////////////////////////////////////////////////////////
double dog_math::MaxAbsMatrix(const DblArray& A)
{
#ifdef CHECK_BOUNDS
  assert_eq(A.get_num_ind(),2);
#endif

  const int m1 = A.get_ind_length(1);
  const int m2 = A.get_ind_length(2);

  double tmp = fabs(A.get(1,1));
  for( int i=1; i<=m1; i++)
    for( int j=1; j<=m2; j++)
      { tmp = Max(tmp, fabs(A.get(i,j)) ); }

  return tmp;
}
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Compute the matrix product: A*B. Save output in C
//
// Need num_colums(A) = num_rows(B),
//        num_rows(C) = num_rows(A),
//      num_colums(C) = num_colums(B)
// e.g., if A is mxn and B is nxl, then C should be mxl.
//////////////////////////////////////////////////////////////////////////////
void dog_math::MatrixMultiply(const DblArray& A,
                              const DblArray& B,
                              DblArray& C)
{
  const int rowsA = A.get_ind_length(1);
  const int colsA = A.get_ind_length(2);
  const int colsB = B.get_ind_length(2);

#ifdef CHECK_BOUNDS
  // Quick error check:
  const int rowsB = B.get_ind_length(1);
  assert_eq( A.get_num_ind(), 2 );
  assert_eq( B.get_num_ind(), 2 );
  assert_eq( C.get_num_ind(), 2 );
  assert_eq( colsA, rowsB );
  assert_eq( rowsA, C.get_ind_length(1) );
  assert_eq( colsB, C.get_ind_length(2) );
#endif

  DblArray Btranspose(colsB,rowsA);
  for( int i=1; i<=rowsA; i++ )
    for( int j=1; j<=colsB; j++ )
      { Btranspose.fetch(i,j) = B.get(j,i); }

  for( int i=1; i<=rowsA; i++ )
    for( int j=1; j<=colsB; j++ )
      {
        double tmp = 0.0;
        for( int k=1; k<=colsA; k++ )
          { tmp += A.get(i,k)*Btranspose.get(j,k); }
        C.fetch(i,j) = tmp;
      }
}
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Compute the product: A*v. Save output in b.
//////////////////////////////////////////////////////////////////////////////
void dog_math::MatVecMultiply(const DblArray& A,
                              const DblArray& v,
                              DblArray& b)
{
#ifdef CHECK_BOUNDS
  // Quick error check:
  assert_eq( A.get_num_ind(), 2 );
  assert_eq( v.get_num_ind(), 1 );
  assert_eq( b.get_num_ind(), 1 );
  assert_eq( A.get_ind_length(2), v.get_ind_length(1) );
  assert_eq( A.get_ind_length(1), b.get_ind_length(1) );
#endif

  const int m1 = A.get_ind_length(1);
  const int m2 = A.get_ind_length(2);

  for( int k=1; k<=m1; k++ )
    {
      double tmp = 0.;
      for( int j=1; j<=m2; j++ )
        { tmp += A.get(k,j)*v.get(j); }
      b.set( k, tmp );
    }
}
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Computes the factorial of an integer and then recasts it as a double
//////////////////////////////////////////////////////////////////////////////
double dog_math::dfactorial(int n)
{
  double factorial = 1;
  for(int i = 1; i <= n; ++i)
    {
      factorial *= double(i);
    }
  return factorial;
}
//////////////////////////////////////////////////////////////////////////////
